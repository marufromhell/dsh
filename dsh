#!/usr/bin/env python3
import serial
import click
import re
import sys
import os
r=0
g=0
b=0
bl=0
class MockSerial:
    def __init__(self, *args, **kwargs):
        self.portstr = kwargs.get('port', '/dev/ttyACM0')
        self.buffer = []
        self.closed = False
        self.r = 0
        self.g = 0
        self.b = 0
        self.bl = 0

    def write(self, data):
        click.echo(f"[MOCK SERIAL WRITE] {data!r}")
        self.buffer.append(data)

    def readline(self):
        if self.buffer:
            last = self.buffer[-1]
            if b'upload' in last:
                return b"Writing to storage...\n"
            elif b'\x03' in last:
                return b"Write complete\n"
            elif b'led' in last:
                parts = last.split()
                if len(parts) == 3:
                    color = parts[1].decode() if isinstance(parts[1], bytes) else str(parts[1])
                    rgb = parts[2].decode() if isinstance(parts[2], bytes) else str(parts[2])
                    try:
                        rgb_val = int(rgb)
                    except ValueError:
                        click.echo(f"Invalid RGB value: {rgb}\nsetting to 0")
                        rgb_val = 0
                    if color == "r":
                        if rgb_val == 0:
                            self.r = 0
                        else:
                            self.r += rgb_val
                    elif color == "g":
                        if rgb_val == 0:
                            self.g = 0
                        else:
                            self.g += rgb_val
                    elif color == "b":
                        if rgb_val == 0:
                            self.b = 0
                        else:
                            self.b += rgb_val
                    elif color == "bl":
                        if rgb_val == 0:
                            self.bl = 0
                        else:
                            self.bl += rgb_val
                    click.echo(f"LED color added to {color} with RGB value {rgb_val}")
                    click.echo(f"current color: r:{self.r} g:{self.g} b:{self.b} bl:{self.bl}")
                    return f"LED {color} set to {rgb_val}\n".encode()
        return b"MOCK RESPONSE\n"

    def close(self):
        self.closed = True
        print("[MOCK SERIAL CLOSED]")
    
"""
Flipper Zero shell script runner
email: maru@lithium-dev.xyz
signal: maru.222
BTC: 16innLYQtz123HTwNLY3vScPmEVP7tob8u
ETH: 0x48994D78B7090367Aa20FD5470baDceec42cAF62 
XMR: 49dNpgP5QSpPDF1YUVuU3ST2tUWng32m8crGQ4NuM6U44CG1ennTvESWbwK6epkfJ6LuAKYjSDKqKNtbtJnU71gi6GrF4Wh
"""
@click.command()
@click.option('-p', '--port', default='0', show_default=True, help='Serial port number')
@click.option('-V', '--verbose', is_flag=True, help='Enable verbose output')
@click.option('-m', '--mock', is_flag=True, help='mock serial port')
@click.argument('script')
def main(port, script, verbose, mock):
    global ser
    if mock:
        ser = MockSerial(port=port)
        click.echo("Mock serial port initialized.")
        click.echo(f"Connected to: {ser.portstr}")
        click.echo("Running in mock mode.")
    
    if verbose:    click.echo("dsh m1.0h5")
    if verbose:    click.echo("main called")
    # Add script directory to Python path
    if verbose:    click.echo("adding path")
    script_dir = os.path.dirname(os.path.abspath(script))
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)
    if verbose:    click.echo("success!")
    if verbose:    click.echo("running script: " + script)
    with open(script, "r", encoding="utf-8") as file:
        contents = file.read()
    if verbose:    click.echo("script loaded")
    if verbose:    click.echo("connecting to flipper on /dev/ttyACM" + str(port))
    try:
        if not mock:
            ser = serial.Serial(f"/dev/ttyACM{port}", 115200, timeout=1)
        ser.write(b'\n\r')
        # Wait for initial response
        response = ser.readline()
        if not response:
            click.echo("Error: No response from Flipper Zero")
            sys.exit(1)
            
        click.echo(f"connected to: {ser.portstr}")
        
        # READ ASCII ART with timeout
        counter = 0
        while counter < 27:
            line = ser.readline()
            counter += 1
            
        if verbose:    click.echo("ascii art read")
    except KeyboardInterrupt:
        click.echo("\nExiting...")
        ser.close()
        sys.exit(0)
    except Exception as e:
        click.echo(f"Error connecting to Flipper Zero: {e}")
        sys.exit(1)

    #this is a weird spot for this function, but it needs ser to be defined before the function is defined.
    def upload(file_path_local, destination_remote):
        if not destination_remote.startswith('/ext'):
            destination_remote = f'/ext{destination_remote}'
        
        with open(file_path_local, "r") as file:  # Changed to text mode
            file_data = file.read()
        
        # Ensure file ends with newline
        if not file_data.endswith('\n'):
            file_data += '\n'
        
        # Send storage write command
        ser.write(f"storage write {destination_remote}".encode()) #hate the game not the player, i genuinly had no clue how to do ascii operations over serial before this
        ser.write(b'\x0D\x0A')  # Ctrl+Enter
        ser.readline()
        
        # Write file data with proper line endings
        ser.write(file_data.encode().replace(b'\n', b'\x0D\x0A'))
        
        # Send Ctrl+C (ASCII code 0x03) to end write mode
        ser.write(b'\x03')
        ser.write(b'\x0D\x0A')  # Ctrl+Enter

        response = ser.readline().decode('utf-8').strip()
        if "error" in response.lower():
            click.echo(f"Upload failed: {response}")
        else:
            if verbose:    click.echo(f"Uploaded {file_path_local} to {destination_remote}")
    if verbose:    click.echo("starting interpreter")
    in_block = False
    block_lines = []
    local_vars = {}
    for line in contents.splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        if not in_block and stripped.startswith("{") and not stripped.endswith("}"):
            in_block = True
            block_lines = [stripped.lstrip("{")]
            continue
        elif in_block:
            if verbose:    click.echo("block found")
            if stripped.endswith("}"):
                block_lines.append(stripped.rstrip("}"))
                code = "\n".join(block_lines)
                if verbose:    click.echo(f"EXECUTING BLOCK:\n {str(code)}")
                exec(code, {}, local_vars)
                in_block = False
                block_lines = []
            else:
                block_lines.append(line)
            continue
        elif stripped.startswith("{") and stripped.endswith("}"):
            code = stripped[1:-1]
            exec(code, {}, local_vars)
            continue
        elif line.startswith("upload"):
            parts = line.split()
            if len(parts) == 3:
                file_path = parts[1]
                destinationname = parts[2]
                upload(file_path, destinationname)
                click.echo(ser.readline())
                if verbose:    click.echo("Uploaded " + file_path + " to " + destinationname)
                continue
        
            
        def repl(match):
            expr = match.group(1)
            try:
                return str(eval(expr, {}, local_vars))
            except Exception as e:
                return f"<ERR:{e}>"

        processed_line = re.sub(r'\{([^{}]+)\}', repl, line) #lowkey forgot i forgot to use the extract_code_block function but this works better
        ser.write(processed_line.encode('utf-8') + b'\n\r')
        click.echo(ser.readline())

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        click.echo("\nExiting...")
        ser.close()
        sys.exit(0)
    except Exception as e:
        click.echo(f"An error occurred: {e}")
        sys.exit(1)

